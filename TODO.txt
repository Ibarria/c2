* Have an Interpreter class for
** Pool allocation of AST
** Predefined types (INT, FLOAT, STRING, BOOL)
* Support pointers
* Write bytecode instruction specification
* Write bytecode generator
* write bytecode interpreter
* write cast function (built in)
* check that a variable exists before using it (assignment, expression, etc)
* implement local functions on the C generator
* do check for types when calling a function
* check the type of return values in a function, and the existence of a return statement
* check that a function call is a variable of type function
* do check for size when doing explicit declaration (s8 x := 512)
* do check for types on assignment
* do conditionals
* do for loop (with it)
* struct support
* enum support
* support default initializers (implicit to 0)
* support for explicit defaults
* support to skip default initialization
* support for new and delete
* support for defined size arrays
* support for dynamic arrays
* support for parameters of type array, string
* support for return type of array, string
* support 'import' directive, where structs, enums, vars and functions are declared tied to a dll/lib
** ensure imports are separate libraries, do not use extension for imports, define what libs to 
** link against (or make it implicit, with a custom dll)
* support  'load' directive, where the Parser will try to load a new text file and put things together
** protect against recursive loads

- create `true` and `false` basic types for bool
- basic 'import' support added

#####  LEXER  #####
* Support _ in numbers for clarity

- Number to support float (period)
- Support numbers of differnt precision
- Handle line comments
- We need a way to know what line, column we're parsing when there is an error
- Lexer.cpp needs a way to handle errors and print to screen
- Handle String type
- Handle multiline comments

#####   PARSER  #####
* Be able to parse conditionals
- Create Basic AST hierarchy
- Be able to parse variable declaration
- Be able to parse functions
- Be able to parse blocks
- Be able to parse assignments
- Be able to parse Math expressions
- Print AST on the screen

##### Thoughts on Arrays ##### 
We support 3 types of arrays:
 1) Very C like array, size known at compile time:
    array_1 := [50] u16;
	
 2) Static array, where all elements have a valid value
    array_2 := [] u16;
	array_2[30]; => access element 30. Bounds check possible
	array_2.data => this is a ^u16
	array_2.count => number of elements in the array
	Both data and count are visible and can be assigned and modified (at your peril)

 3) Dynamic array, size can change and not all elements might be used
    array_3 := [..] u16;
	array_3[30]; => access element 30. Bounds check possible
	array_3.data => this is a ^u16
	array_3.size => number of elements in the array total
	array_3.count => number of used, valid elements in the array
	
 How do these arrays convert to each other? 
  - A Dynamic array can convert to a static array, by losing information? NO
    This has the risk that if the conversion is on a function that tries to access internals,
	it could break since internals differ. 
  - A C like array converts to static array?
    Playing with internals is again a risk, but less so than in the previous example
	This would force C arrays to store the size, when in most cases it would be enough to just 
	use the size from the AST. Maybe provide the size if the array is ever passed in a function. 
 
	
